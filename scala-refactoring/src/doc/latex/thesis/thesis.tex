\documentclass[10pt,a4paper,oneside]{scrreprt}
\usepackage{mystyle}

\begin{document}

\newcommand{\subtitlename}{Master's Thesis}
\newcommand{\titlename}{Refactoring for Scala}

\include{0_front}

\chapter*{Abstract}

\pagenumbering{roman}

This thesis..


\chapter*{Management Summary}

This documentation 

\newpage

\setcounter{tocdepth}{2}

\tableofcontents

\newpage

\pagenumbering{arabic}

\chapter{Introduction}
\section{Problem Outline}
\section{Thesis Goals}

\chapter{Refactoring Library}

describes the three main modules of the refactoring library.

\section{Overview}
\section{Analysis}

explain the symbol index to resolve symbols to trees

\section{Transformation}

At the heart of every refactoring lies a \textit{transformation} that takes the current program in its abstract syntax tree form and transforms it into its refactored form. Such a transformation can be as simple as changing names -- think of the Rename refactoring -- or restructure large parts of the AST as in an Extract or Move refactoring. 

Often, a larger refactoring comprises many smaller transformations. A simple example is the Extract Method refactoring, which can be assembled from three basic transformations:

\begin{description}
 \item[Create Method] to introduce a new (empty) method.
 \item[Copy Statements] to copy the selected statements into the newly created method.
 \item[Replace Statements] to replace the original statements that have been copied to the new method with a call to it.
\end{description}

The \textit{replace} transformation itself is again a combination of two even more fundamental transformations: \textit{insert} and \textit{delete}. Once we have our Extract Method transformation, it can then again be combined with other transformations -- for example into an Extract Class refactoring. It should be clear from this that the key to a reusable refactoring library lies in the composability of its transformations. 

Conceptually, chaining simple transformations to build more powerful ones follows the Unix pipes philosophy. The design of this implementation was inspired by the Stratego program transformation tool-set (referenz) and the Kiama language processing library (referenz). Functional programming also uses the term \textit{combinator} to denote functions that can be combined and yield new functions of the same kind. An example of this are parser combinators (referenz), which are also contained in the Scala standard library.

In contrast to unix pipes that operate on their input line by line, performing transformations on trees adds an additional dimension. When transforming trees, we are also concerned with questions on how we want to traverse the tree -- i.e. top-down or bottom-up -- and to which children a transformation should be applied. The presented implementation handles all these concerns in a uniform way.

In the remainder of this section, we will develop the basics of our transformation combinators and show examples of their usage.

\subsection{Transformations}

A refactoring transformation is essentially a function that transforms a tree into an other tree. But because most transformations do not apply to all kinds of possible trees, we model a transformation as a function of type $Tree\Rightarrow Option[Tree]$, making use of Scala's \src{Option} monad to indicate inability to transform. In the actual implementation, the transformations are implemented generically as a \src{Transformation[A,~B]} that extend \src{A~$\Rightarrow$~Option[B]}:

\begin{lstlisting}
abstract class Transformation[A, B] extends (A %$\Rightarrow$% Option[B]) {
  self %$\Rightarrow$%
  def apply(in: A): Option[B]
  ...
}
\end{lstlisting}

The explicit self type annotation\footnote{In this case, think of the self type annotation as an alias for \src{this} that can be used in the body of the class.} will be used later in the implementation of the combinators. Note that all transformations are implemented generically, but to make the explanations more clear, we will assume that they are used to transform trees.

Transformations can be created from partial functions using the \src{transform} convenience function. As an example, we create a transformation that reverses the order of a class, trait, or object's member definitions and apply it to a given template instance.

\begin{lstlisting}
def transform[A, B](f: PartialFunction[A, B]) = new Transformation[A, B] {
  def apply(t: A): Option[B] = f lift t
}

val reverseTemplateMembers = transform[Tree, Tree] {
  case t: Template %$\Rightarrow$% t copy (body = t.body.reverse)
}

val result: Option[Tree] = reverseTemplateMembers(template)
\end{lstlisting}

Now that we have a way to create single transformations, we need to be able to combine them. To do this in various ways, we introduce several combinators. We use a notational shortcut to denote transformations: $A \overset{t}{_\rightarrow} [B]$ is a \src{Transformation [A, B]}.

There also exist two basic transformations, one that always succeeds, returning its input unchanged, and one that always fails, independent of its input. Depending on the context, the alias \src{id} for \src{succeed} might be a better fit and is provided as well.

\begin{lstlisting}
def succeed[A] = new Transformation[A, A] {
  def apply(a: A): Option[A] = Some(a)
}

def id[X] = success[X]

def fail[A] = new Transformation[A, A] {
  def apply(a: A): Option[A] = None
}
\end{lstlisting}

\subsection{Combinators}

There are several existing combinators already implemented in the library. On the right of each paragraph, the symbolic or alphanumeric name and type of the transformation is shown.

\paragraph{Sequence} \hfill \lstinline{*>: } $(A \overset{t}{\rightarrow} [B]) \Rightarrow (B \overset{t}{\rightarrow} [C]) \Rightarrow (A \overset{t}{\rightarrow} [C])$

\vspace{7pt} Combines two transformations so that the second one is only applied when the first one succeeded. The result of the first transformation is passed into the second one. This is implemented as the \src{andThen} method -- or alternatively with the \src{*>} operator -- on \src{Transformation}, which takes the second transformation as a by-name parameter:

\begin{lstlisting}
  def andThen[C](t: %$\Rightarrow$% Transformation[B, C]) = new Transformation[A, C] {
    def apply(a: A): Option[C] = {
      self(a) flatMap t
    }
  }
  def *>[C](t: %$\Rightarrow$% Transformation[B, C]) = andThen(t)
\end{lstlisting}


\paragraph{Choice} \hfill \lstinline{|>: } $(A \overset{t}{\rightarrow} [B]) \Rightarrow (A \overset{t}{\rightarrow} [B]) \Rightarrow (A \overset{t}{\rightarrow} [B])$

\vspace{7pt} Combines two transformations so that the second one is only applied in case the first one fails. The implementation is directly based on the underlying \src{Option} type in the \src{orElse} method on \src{Transformation} and also has an operator alias:

\begin{lstlisting}
  def orElse(t: %$\Rightarrow$% Transformation[A, B]) = new Transformation[A, B] {
    def apply(a: A): Option[B] = {
      self(a) orElse t(a)
    }
  }
  def |>(t: %$\Rightarrow$% Transformation[A, B]) = orElse(t)
\end{lstlisting}

With these two combinators, we are already able to represent conditional transformations. For example, given a transformation \src{isClass} that acts as a predicate, and two transformations \src{a} and \src{b} that represent the two possible branches the transformation can take, we can combine them into a new transformation \src{isClass *> a |> b} that executes the \src{a} transformation if the \src{isClass} transformation succeeds or \src{b} if either \src{isClass} or \src{a} fails.

Note that due to Scala's precedence rules, the \src{|>} combinator has a lower precedence than \src{*>}.

\paragraph{Predicate} \hfill \lstinline{predicate: } $(A \overset{?}{\rightarrow} Boolean) \Rightarrow (A \overset{t}{\rightarrow} [A])$

\vspace{7pt} As we have seen, transformations can be used as predicates, but usually we want to construct a predicate from a function that returns a boolean value. This can be done with the \src{predicate} function which create a transformation from a partial function.

\begin{lstlisting}
def predicate[A](f: %$\Rightarrow$% PartialFunction[A, Boolean]) = new Transformation[A, A] {
  def apply(a: A): Option[A] = if (f.isDefinedAt(a) && f(a)) Some(a) else None
}
\end{lstlisting}

\paragraph{Not} \hfill \lstinline{not: } $(A \overset{t}{\rightarrow} [A]) \Rightarrow (A \overset{t}{\rightarrow} [A])$

\vspace{7pt} A combinator that inverts a transformation. Given a transformation that succeeds, then \src{not} will fail. Should the given transformation fail, then \src{not} returns the original input unchanged. This behavior is useful for transformations that act as predicates; \src{not} can be implemented using the \src{fail} and \src{id} transformations as follows.

\begin{lstlisting}
def not[A](t: %$\Rightarrow$% Transformation[A, A]) = t *> fail |> succeed
\end{lstlisting}

Now that we have several means to specify and combine our transformations, we also need a way to apply them to a whole AST, instead of just single tree nodes. For this, there exist several traversal strategies.

\subsection{Traversal}

Applying a transformation to a single tree element is not difficult, but once we want to traverse the whole AST, we need a way to apply a transformation to all children of a tree node and to construct a new tree from the result of the transformation operation. Note that traversal strategies are also just transformations that can again be combined.

\paragraph{All} \hfill  $\forall: (A \overset{t}{\rightarrow} [B]) \Rightarrow (A \overset{t}{\rightarrow} [B])$

\vspace{7pt} Takes a transformation and creates a new one that applies the given transformation to all children, returning a single tree. Because there is no generic way to get all children and construct a new tree, we constrain the type parameter \src{A} to be convertible to $(A \Rightarrow B) \Rightarrow B$. This means that the user of the generic transformation has to pass us its children and create a new tree. When a child cannot be transformed, \src{all} immediately aborts and returns \src{None}.

\begin{lstlisting}
def all[A <%\%% (A %$\Rightarrow$% B) %$\Rightarrow$% B, B](t: %$\Rightarrow$% Transformation[A, B]) = new Transformation[A, B] {
  def apply(a: A): Option[B] = {
    Some(a(child %$\Rightarrow$% t(child) getOrElse (return None)))
  }
}
def %$\forall$% [A <%\%% (A %$\Rightarrow$% B) %$\Rightarrow$% B, B](t: %$\Rightarrow$% Transformation[A, B]) = all(t)
\end{lstlisting}

(\src{X <\% Y} is called a \textit{view bound} and demands that there exists an implicit conversion from type \src{X} to \src{Y}. This is less constrictive than \src{X <: Y}, where \src{X} has to be a subtype of \src{Y}. In our case, we can then treat \src{a} as if it were of type \src{(A $\Rightarrow$ B) $\Rightarrow$ B}. This allows us to apply the transformation to the children of \src{a}.)

\paragraph{Some} \hfill $\exists: (A \overset{t}{\rightarrow} [A]) \Rightarrow (A \overset{t}{\rightarrow} [A])$

\vspace{7pt} The \src{all} traversal only succeeds when the transformation can be applied to all children. If children that cannot be transformed should simply be kept and passed to the new tree unchanged, we can use the \src{some} transformation or its $\exists$ alias.

\begin{lstlisting}
def some[A <%\%% (A %$\Rightarrow$% A) %$\Rightarrow$% A](t: Transformation[A, A]) = %$\forall$%(t |> id[A])
def %$\exists \hspace{11pt}$% [A <%\%% (A %$\Rightarrow$% A) %$\Rightarrow$% A](t: Transformation[A, A]) = some(t)
\end{lstlisting}

Using the \src{id} transformation, we retain the original tree should the transformation not be applicable. A consequence of this is that the transformation needs to be done between the same types.

\paragraph{Once} \hfill \lstinline{once: } $(A \overset{t}{\rightarrow} [A]) \Rightarrow (A \overset{t}{\rightarrow} [A])$

\vspace{7pt} Applies a transformation and stops on the first successful application... not yet implemented.
\\\\
The next step after being able to apply a transformation to a tree or all of its children is to expand this to the AST as a whole. We can distinguish between two fundamental ways of transforming a tree: either in a top-down or bottom-up fashion.

\paragraph{Top Down} \hfill $\downarrow: (A \overset{t}{\rightarrow} [A]) \Rightarrow (A \overset{t}{\rightarrow} [A])$

\vspace{7pt} Top-down application of a transformation applies it to the parent first and then descends into its children. The consequence is that once a child gets transformed, its children are still in their original, untransformed state.

\begin{lstlisting}
  def %$\downarrow$ \hspace{19pt} %      [A <%\%% (A %$\Rightarrow$% A) %$\Rightarrow$% A](t: Transformation[A, A]) = t *> %$\forall$%(%$\downarrow$%(t))
  def topdown[A <%\%% (A %$\Rightarrow$% A) %$\Rightarrow$% A](t: Transformation[A, A]) = %$\downarrow$%(t)
\end{lstlisting}

\paragraph{Bottom Up} \hfill $\uparrow: (A \overset{t}{\rightarrow} [A]) \Rightarrow (A \overset{t}{\rightarrow} [A])$

\vspace{7pt} Bottom-up application first descends into the children of a tree and processes the parent after the children. Thus once a tree gets transformed, its children have already been transformed.

\begin{lstlisting}
  def %$\uparrow$ \hspace{27pt} %      [A <%\%% (A %$\Rightarrow$% A) %$\Rightarrow$% A](t: Transformation[A, A]) = %$\forall$%(%$\uparrow$%(t)) *> t
  def bottomup [A <%\%% (A %$\Rightarrow$% A) %$\Rightarrow$% A](t: Transformation[A, A]) = %$\uparrow$%(t)
\end{lstlisting}

Combining all these transformations with combinators and traversal strategies allows us to describe transformations in a very concise way, as we can see in the following examples.

\subsection{Examples}

As a first example, let us write a transformation that replaces all trees in the AST which do not have a range position with the \src{EmptyTree}.

\begin{lstlisting}
val hasRangePosition = predicate[Tree] {
  case t: Tree =>  t.pos.isRange
}

val emptyTree = transform[Tree, Tree] {
  case _ => EmptyTree
}

val keepTree = id[Tree]

val removeNonRangePositionTrees = %$\downarrow$%(hasRangePosition *> keepTree |> emptyTree)
\end{lstlisting}

.. hier noch mehr ..


\section{Code Generation}

Once our abstract syntax tree has been refactored, we need to convert it back into its textual source code representation. This process comprises two main steps: the detection of modifications to minimize the amount of code that is regenerated and the actual source generation.

The first step is necessary because we -- in contrast to many other implementations -- do not keep track of modifications to the AST while they are happening but reconstruct this information afterwards. This allows us to keep the transformation simpler but makes the code generation more complicated. This tradeoff is worthwile because we intend the library to be reused and the transformations to be implemented by third parties.

The AST after the refactoring may contain several kinds of modifications. Trees can be moved around, deleted and new trees can be introduced. From the transformations we know that trees that are moved around keep their original position information, and newly created trees get a \src{NoPosition} attribute. This allows us to detect changes and can later be used during source generation to preserve the layout of already existing trees. 

\subsection{Modification Detection}

The primary goal of modification detection is to reduce the amount of trees that need to be regenerated. In principle, we just traverse the AST and compare each tree to its original tree (with the retained position information). New trees with a \src{NoPosition} are always considered changed. ...algorithmus erklÃ¤ren.


Once we have identifier all top level tree changes, we start generating source code for them. 

\subsection{Code Generation}

The AST does by its very nature not contain all the information that is necessary to fully reconstruct its original textual representation. Also, syntactic sugar of the programming language is usually not represented in the AST but generalized. An example for this are Scala's \src{for} comprehensions. They are equivalent with function calls to \src{map, filter, flatMap,} and \src{foreach}. This means that the two statements in the following listing have the same representation in the AST.

\begin{lstlisting}
val v1 = List(1,2,3) map (i => i * 2)
val v2 = for(i <- List(1,2,3)) yield i * 2
\end{lstlisting}

Other things that are not mentioned explicitly in the AST are parenthesis, commas and many other tokens. In the context of source generation, we will call them layout elements, or just \textit{layout}. 

If we were only interested in a semantically equivalent program, we could simply pretty print the AST to get back the source code. No user of a refactoring tool would accept this, so we need another technique. The source code is always available to the refactoring tool, and with the position information on the trees, we have a means to look up the original source code for a tree.

Other refactoring tools (TODO ref) have used various approaches to solve this problem. For many cases -- for example rename -- it is acceptable to pretty print the code as long as only very small regions of the program change. This approach can be problematic -- for example with the Extract Method refactoring, where arbitrary large parts of the program are moved around. A tool can solve this situation by cut-and-pasting the body of the extracted method. This approach is not feasible for us because we need a generic way to handle all kinds of unforseeable changes to the source code.

\subsubsection{Preserving Layout}

Our approach is based on using two different kinds of source printers: one that pretty prints code  and another one that reuses the existing code where it is possible. The pretty printer simply prints the code with a default layout and is used for trees that were introduced in the transformations. The reusing printer takes the existing layout and makes sure all needed layout elements are present. How this is done will be explained in more detail later.

The source generation algorithm then alternates between these two printers during the code generation process.

Now we just need to know how we can reuse the existing layout. What we need is a way to decide how all these layout elements can be associated to their enclosing trees. If we take a look at the following listing, we can see several occurences of whitespace and other layout, like the three comments and the braces.

\begin{lstlisting}
package p //TODO
// myclass
class MyClass(a: Int /* the int */) {
}
\end{lstlisting}

Because no rules of the programming language dictate how the layout can be associated with the other parts of the program, we have to guess how to divide the layout and associate it with the surrounding trees. Often this can be done by taking the types of the adjacent trees into consideration and then divide the layout according to some rules and regular expressions. For example, one rule says that the layout between two enclosing value definitions are split by comma, or by newline if there is no comma present. So when the values are part of an argument list, they will get comma-separated, and if they are definitions, the layout will be split at the end of the line, so that the first value will get all layout that follows on its line. Comments can be handled with the same rules as well: a comment on a preceding and otherwise empty line is associated with the following tree.

Let us take a look at a concrete example. \figref{figure:ast_with_layout} shows the AST of the listing and how the layout elements have been associated with the left and right sides of a tree. Note that the \src{class} and \src{package} keywords are also considered layout, this is because they are not represented in the AST with their own tree and position information.

\begin{figure}
 \centering
 \includegraphics[width=0.8\linewidth]{ast_with_layout.pdf}
 \caption{bla}
 \label{figure:ast_with_layout}
\end{figure}

Once we have identified the layout that belongs to a tree, we can use it during the source generation. It is easy to see that when we would delete the parameter in the above AST, then the comment would be removed along with it.

Another issue that concerns both the pretty and the reusing printer is the indentation. When a new statement in a block of other statements is inserted, we want it to have the same indentation as its siblings. For this, the printers also keep track of the currently desired indentation


Whether we can reuse existing code or have to invoke the pretty printed needs to be decided for each tree in the AST. This gives us the following simplified pseudo code for the source generation algorithm.

\begin{lstlisting}
generateSource(tree) = 
  if tree.sourceCanBeReused
    existingLeadingLayout + print(tree) + (tree.children foreach generateSource) + existingTrailingLayout
  else
    print(tree) + tree.children foreach generateSource
\end{lstlisting}

The implementation differs from the pseudo code in several ways. For example, the pretty printer needs to generate keywords, parenthesis and other tokens that are needed to get a correct program. Another thing that needs special treatment is the indentation, which is passed along and the code is indented where necessary.





 The basic algorithm looks as follows.





\chapter{Refactoring Implementations}

describe each refactoring, with examples, problems, corner cases and the actual implementation. shows the library internals from the previous chapter in action.

\section{Rename}
\section{Organize Imports}
\section{Extract Method}
\section{Extract Local}


\chapter{Integration}

how can the refactorings be integrated into a new tool?
how does the current integration look like

\chapter{Testing}

don't describe the unit tests but show how the refactoring tests work and how one could write new test cases.

\chapter{Outlook}

\section{Acknowledgments}

I would like to thank ..

\section{Future Work}

what is left to do, how can the work be extended

\appendix

Scala terminology appendix

\chapter{User Guide}

User guide, also in HTML on the Wiki. Describes the usage of the implemented refactoring along with their shortcomings.

\chapter{Developer How-To}

A short introduction by example, for more depth, refer to the main documentation.

\include{9_appendix}
\include{91_scala_ast}

\clearpage
\bib

\end{document}
